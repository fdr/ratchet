#!/usr/bin/env python
import argparse
import collections
import datetime
import os
import re
import signal
import subprocess
import sys
import time


def port_to_pid(port):
    """
    Maps a port being listened upon to a PID

    This is useful to stop the root process of network servers.  Left
    untreated is the case of multiple bindings to the same port on
    different interfaces: multiple matches will result in an
    exception.
    """

    p = subprocess.Popen(
        ['lsof', '-P', '-n', '-i',
         'TCP:' + str(port), '-s', 'TCP:LISTEN', '-Fp'],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdout, stderr = p.communicate()

    if p.wait() != 0:
        return None
    else:
        m = re.match(r'^p(?P<pid>\d+)$', stdout)

        if m:
            return int(m.groupdict()['pid'])
        else:
            raise Exception('pid-to-port returns normally but has '
                            'incomprehensible output: {0}'.format(stdout))

    raise AssertionError('Unintended branch fallthrough')


class OSProcess(collections.namedtuple(
        'OSProcess', ['pid', 'argv'])):

    def is_archiver(self):
        return self.argv.find('archiver') >= 0


def pid_children(root_pid):
    """
    Given a pid, return a list of the child OSProcess-es.

    This is not recursive.  The argv is returned so that the Postgres
    Archiver process can be spared from throttling by using string
    matching to identify it.

    Raises an exception if the pid could not be found.
    """
    p = subprocess.Popen(['ps', '--ppid=' + str(root_pid), '-o', 'pid=,args='],
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdout, stderr = p.communicate()

    if p.wait() != 0:
        if stderr == '':
            # ps likes to return 1 when no processes are returned.  It
            # makes no exit-code differentiation between 'erroneous
            # user input', 'no pid', or 'no children of pid', so don't
            # even bother trying.
            return []
        else:
            raise Exception('process listing did not complete successfully: ' +
                            stderr)

    parts = [line.strip().split(' ', 1)
             for line in stdout.strip().split('\n')]

    return [OSProcess(pid=int(pid), argv=argv) for (pid, argv) in parts]


def force_naptime(parent_pid, nap_quantum):
    """
    Put a parent and its child processes to sleep for a while

    This function is intended to be called repeatedly to cause a
    degradation in performance, as each naptime is relatively small.

    """
    SIGCONT = signal.SIGCONT
    SIGSTOP = signal.SIGSTOP
    parent_pid = int(parent_pid)

    # Record stopped processes before actually sending the signal;
    # since spurious SIGCONTs are mostly harmless but dangling
    # SIGSTOPs are dangerous, optimize for sending SIGCONT even if
    # there is no preceding SIGSTOP in error cases.
    children_maybe_stopped = set()

    def stop_pid_and_record(pid):
        children_maybe_stopped.add(pid)
        os.kill(pid, SIGSTOP)

    try:
        # Stop the parent first, so it cannot create children.
        os.kill(parent_pid, SIGSTOP)

        children = pid_children(parent_pid)

        # Send SIGSTOP to children, except the archiver.
        for osp in children:
            if not osp.is_archiver():
                stop_pid_and_record(osp.pid)

        # Wait around a while while everyone is taking a nap
        time.sleep(nap_quantum)
    finally:
        # Wake everyone up
        for pid in children_maybe_stopped:
            os.kill(pid, SIGCONT)

        os.kill(parent_pid, SIGCONT)


def force_wake(parent_pid):
    """
    A paranoid, unconditional wake-up call

    Should be called after throttling is complete, in case this
    program was termianted by an OOM killer or even just sketchy OOM
    handling by Python.
    """
    for pid in [parent_pid] + [osp.pid for osp in pid_children(parent_pid)]:
        try:
            os.kill(parent_pid, signal.SIGCONT)
        except:
            # Stop at nothing and soldier on, including processes that
            # may disappear for whatever reason (kernel or concurrent
            # user shenanigans, such as kill -9 by an operator)
            pass


def nap_until(parent_pid, deadline, nap_quantum, wake_quantum):
    """
    Cause continuous napping until some future datetime.

    """
    while datetime.datetime.now() < deadline:
        force_naptime(parent_pid, nap_quantum)
        time.sleep(wake_quantum)


def self_test():
    """
    Quick and dirty self-test

    Exercises some code paths without much tooling.
    """
    import socket

    print 'Beginning self test...'

    print '  Testing un-limited speed of a process; for comparison'

    TEST_ADDR = ('0.0.0.0', 12341)

    def fork_burner(title):
        deadline = datetime.datetime.now() + datetime.timedelta(seconds=5)
        pid = os.fork()
        if pid == 0:
            # Have a soon-zombie child process to exercise some other
            # code paths.
            if os.fork() == 0:
                sys.exit(0)

            # In this flow of control: in the victim/child process

            # Listen on a socket to test the port-to-pid resolution.
            # Vestigial in tests that do not support it, and
            # cleared/freed by exiting the entire process.
            s = socket.socket()
            s.bind(TEST_ADDR)
            s.listen(0)

            i = 0
            while datetime.datetime.now() < deadline:
                i += 1

            print '{0}: counted {1} times'.format(title, i)
            sys.exit(0)
        else:
            return int(pid)

    pid = fork_burner('Unthrottled process')
    os.waitpid(pid, 0)

    print '  Testing throttled process; it should loop fewer times'

    # Deadline comes somewhat safely before the process finishes
    napper_deadline = datetime.datetime.now() + datetime.timedelta(seconds=4)

    pid = fork_burner('Throttled process')
    nap_until(pid, napper_deadline, 0.5, 0.1)
    os.waitpid(pid, 0)

    print '  Testing unconditional wake; should terminate'
    pid = fork_burner('Paused process')
    os.kill(pid, signal.SIGSTOP)
    force_wake(pid)
    os.waitpid(pid, 0)
    print '  Woken.'

    print '  Test port-pid resolution'
    pid = fork_burner('Process just to bind a port')
    found_pid = port_to_pid(TEST_ADDR[1])
    if found_pid != pid:
        raise Exception('Mismatch: created pid was {0}, '
                        'but resolved the pid {1}'.format(pid, found_pid))
    else:
        print '  ...resolved properly'

    os.kill(pid, signal.SIGTERM)

    print '  Test renicing'
    pid = fork_burner('Reniced process')
    summary = maybe_renice(pid, 10, 11, 5)
    os.waitpid(pid, 0)

    print '  Summary: succeeded={0} failed={1}'.format(*summary)

    print 'Done.'


def maybe_renice(parent_pid, parent_nice, child_nice, archiver_nice):
    """
    Attempt renicing a postmaster and its children

    This procedure implements renicing a postmaster and its children
    per the arguments.  However, it is an attempt to do so, not a
    guarantee -- in particular, PIDs may disappear, causing
    """

    # Check is any niceness settings are below zero and error if we're
    # not root.
    if (any(ns < 0 for ns in [parent_nice, child_nice, archiver_nice]) and
        os.getuid() != 0):
        raise Exception('Ratchet can only set negative niceness settings '
                        'if run as root')

    # Gross way to get side effects to neatly summarize how many
    # renicings succeeded, since CPython closures don't support such
    # mutations.
    renice_stats = [0, 0]

    def do_renicing(osps, ni):
        for osp in osps:
            with open(os.devnull) as devnull:
                ret = subprocess.call(['renice', str(ni), str(osp.pid)],
                                      stdout=devnull)

                if ret == 0:
                    renice_stats[0] += 1
                else:
                    renice_stats[1] += 1

    # Make a bogus argv for the OSProcess, because it's not worth
    # fetching the actual process title, and it is known that the
    # archiver-niceness setting will never match the parent process,
    # the postmaster.
    parent = OSProcess(pid=parent_pid, argv='postmaster')

    # Renice the parent before calling pid_children, so new children
    # of postmaster have the new niceness.
    do_renicing([parent], parent_nice)

    children = pid_children(parent_pid)
    archivers = [child for child in children if child.is_archiver()]

    do_renicing(children, child_nice)
    do_renicing(archivers, archiver_nice)

    return tuple(renice_stats)


def main():
    parser = argparse.ArgumentParser(
        description=('Continuously send SIGSTOP and SIGCONT to '
                     'throttle process activity'))

    subparsers = parser.add_subparsers(title='actions', dest='action')

    # Parent parser for PID-or-Port options that is seen in multiple
    # commands.
    portpid_parent = argparse.ArgumentParser(add_help=False)
    group = portpid_parent.add_mutually_exclusive_group(required=True)
    group.add_argument('--pid', type=int, help='parent process id to apply to')
    group.add_argument('--port', type=int, help='bound port to find pid for')

    # Wake action
    subparsers.add_parser('wake', parents=[portpid_parent],
                          help='wake up a process and its children')

    # Renice action
    renice_action = subparsers.add_parser(
        'renice', parents=[portpid_parent],
        help='change niceness values for postmaster children')

    renice_action.add_argument(
        '-p', '--postmaster', type=int, required=True,
        help='niceness value for the postmaster process')
    renice_action.add_argument('-a', '--archiver', type=int, required=True,
                               help='niceness value for the archiver process')
    renice_action.add_argument('-b', '--backend', type=int, required=True,
                               help='niceness value for the backend processes')

    # Nap action
    nap_action = subparsers.add_parser('nap', parents=[portpid_parent],
                                       help=('make a process and its children '
                                             'pause frequently'))
    nap_action.add_argument('duration', type=int,
                            help='number of minutes to incur naps for')
    nap_action.add_argument('--nap-quantum', type=float, default=0.3,
                            help=('number of seconds to pause at a time; '
                                  'floating point supported'))
    nap_action.add_argument('--wake-quantum', type=float, default=0.3,
                            help=('number of seconds to remain running '
                                  'at a time; floating point supported'))

    # Self-test action
    nap_action = subparsers.add_parser('self-test',
                                       help='Do a quick self-test')

    args = parser.parse_args()

    # If a port was provided instead of a pid, canonicalize by finding
    # the pid and writing it into the args value.
    if hasattr(args, 'port'):
        pid = port_to_pid(args.port)
        if pid is None:
            print ('Could not resolve port {0} to a PID'
                   ' (is ratchet running with sufficient permissions?)'.format(args.port))
            return 1
        else:
            args.pid = pid

    if args.action == 'wake':
        force_wake(args.pid)
    elif args.action == 'nap':
        deadline = (datetime.datetime.now() +
                    datetime.timedelta(minutes=1 * args.duration))
        nap_until(args.pid, deadline, args.nap_quantum, args.wake_quantum)
    elif args.action == 'renice':
        maybe_renice(args.pid,
                     parent_nice=args.postmaster,
                     child_nice=args.backend,
                     archiver_nice=args.archiver)
    elif args.action == 'self-test':
        self_test()
    else:
        raise AssertionError(
            "parser.parse_args should have rejected this input already")

if __name__ == '__main__':
    sys.exit(main())
